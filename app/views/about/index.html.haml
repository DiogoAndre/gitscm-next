- @section = "about"
- @page_title = "Git - Sobre"

- content_for :sidebar do
  = render 'shared/book'

%div#main
  %h1 Sobre

  %ol#about-nav
    %li
      <a href="#branching-and-merging" class="current two-line" id="nav-branching-and-merging" data-section-id="branching-and-merging">Ramificando e fundindo</a>
    %li
      <a href="#small-and-fast" class="two-line" id="nav-small-and-fast" data-section-id="small-and-fast">Pequeno e Rápido</a>
    %li
      <a href="#distributed" class="one-line" id="nav-distributed" data-section-id="distributed">Distribuído</a>
    %li
      <a href="#info-assurance" class="two-line" id="nav-info-assurance" data-section-id="info-assurance">Garantia de Dados</a>
    %li
      <a href="#staging-area" class="two-line" id="nav-staging-area" data-section-id="staging-area">Área de Staging</a>
    %li
      <a href="#free-and-open-source" class="three-line" id="nav-free-and-open-source" data-section-id="free-and-open-source">Livre e de Código Aberto</a>

  %section.about#branching-and-merging.current
    %h2 Ramificando e Fundindo

    %p
      A funcionalidade que faz o Git se diferenciar de praticamente todos os outros SCM por aí é o seu modelo de ramificações(branching).

    %p
      Git permite e te encoraja a ter múltiplas ramificações locais que podem ser inteiramente independente umas das outras. A criação, fusão e remoção das linhas de desenvolvimento leva apenas alguns segundos.

    %p
      Isso quer dizer que você pode fazer coisas como:

    %ul.bullets
      %li
        <strong>Mudança de contexto sem atrito</strong>. Crie um ramo para testar sua ideia, faça uns commits, mude de volta para a origem do ramo, aplique um patch, volte para o ramo, e faça merge.
      %li
        <strong>Linhas de código para uma função específica</strong>. Tenha um ramo que sempre contém apenas o que vai para produção, outro em que você faz merges para testes, e vários outros pequenos para o trabalho do dia-a-dia.
      %li
        <strong>Fluxo de Trabalho baseado em Funcionalidades</strong>. Crie novos ramos para cada nova funcionalidade em que estiver trabalhando, para que possa alterar instantaneamente entre o código principal e o novo. Depois, apague cada ramo quando a funcionalidade for fundida a linha principal.
      %li
        <strong>Experimentação Descartável</strong>. Crie uma ramifação para fazer um experimento, e então perceba que não vai funcionar e apenas a apague, abandone o trabalho, sem que ninguém jamais veja o que fez (mesmo que tenha enviado para outras ramificações enquanto isso).

    %p.center
      <img src="/images/about/branches@2x.png" width="500" height="288" alt="Branches" />

    %p
      Notavelmente, quando você envia para um repositório, não precisa enviar todas as suas ramificações locais. Você pode escolher compartilhar apenas uma, algumas delas, ou todas. Isso deixa as pessoas livres para testar novas ideias sem a preocupação de como e quando será feita o merge ou ter que compartilhar com outros.

    %p
      Existem formas de alcançar isso com outros sistemas, mas o trabalho envolvido é muito mais difícil e propenso a erros. Git deixa o processo incrivelmente fácil e isso muda a foram com que a maioria dos desenvolvedores trabalha depois que eles aprendem.

    %div.bottom-nav
      =link_to "Pequeno e Rápido →", "#small-and-fast", {:class => 'next', 'data-section-id' => 'small-and-fast'}


  %section.about#small-and-fast
    %h2 Pequeno e Rápido

    %p
      <strong>Git é rápido</strong>. Com Git, quase todas as operações são locais, dando uma grande vantagem em velocidade sobre sistemas centralizados que constantemente precisam se comunicar com um servidor em algum lugar.

    %p
      Git foi construído para trabalhar no Kernel Linux, isso quer dizer que desde o início ele já precisava suportar grandes repositórios. Git é escrito em C, reduzingo o overhead associado a linguagens de mais alto nível. Velocidade e performance foram objetivos primários do design do Git desde o princípio.

    %h3 Benchmarks

    %p
      Vamos ver como operações comuns se comparam com
      Subversion, um sistema de controle de versão centralizado que é similar
      ao CVS ou Perforce. <em>Pequeno é mais rápido</em>

    %table{:width => '100%'}
      %tr
        %td
          =raw gchart("Commit A", [['git', 0.649], ['svn', 2.6]])
        %td
          =raw gchart("Commit B", [['git', 1.53], ['svn', 24.7]])
        %td
          =raw gchart("Diff Curr", [['git', 0.257], ['svn', 1.09]])
        %td
          =raw gchart("Diff Rec", [['git', 0.248], ['svn', 3.99]])
        %td
          =raw gchart("Diff Tags", [['git', 1.17], ['svn', 83.57]])
        %td
          =raw gchart("Clone", [['git*', 21.0], ['git', 107.5], ['svn', 14.0]])
      %tr
        %td
          =raw gchart("Log (50)", [['git', 0.012], ['svn', 0.381]])
        %td
          =raw gchart("Log (All)", [['git', 0.519], ['svn', 169.197]])
        %td
          =raw gchart("Log (File)", [['git', 0.601], ['svn', 82.843]])
        %td
          =raw gchart("Update", [['git', 0.896], ['svn', 2.816]])
        %td
          =raw gchart("Blame", [['git', 1.91], ['svn', 3.04]])
        %td
          =raw gchart("Size", [['git', 181], ['svn', 132]])
    %p
      Para os testes, instâncias grandes AWS foram configuradas na mesma zona de disponibilidade. Git e SVN foram instalados em ambas as máquinas, o repositório Ruby foi copiado para 
      os servidores Git e SVN, e operações comuns foram realizadas em ambas.

    %p
      Os comandos não se equivalem exatamente em alguns casos. Aqui, a equivalência pelo menor denominador comum foi buscada. Por exemplo, o teste 'commit' também inclui o tempo de enviar para o Git, apesar de que na maioria do tempo você não estaria enviando para o servidor imediatamente após um commit. No SVN os dois comandos não podem ser separados. 

    %p
      Todos os tempos estão em segundos.

    %table.benchmarks
      %tr
        %th Operação
        %th
        %th.right Git
        %th.right SVN
      =raw rchart("Commit Files (A)", [['git', 0.64], ['svn', 2.60]], "Add, commit and push 113 arquivos modificados (2164+, 2259-)")
      =raw rchart("Commit Images (B)", [['git', 1.53], ['svn', 24.70]], "Add, commit and push 1000 images de 1k")
      =raw rchart("Diff Current", [['git', 0.25], ['svn', 1.09]], "Diff 187 arquivos alterados (1664+, 4859-) contra o último commit")
      =raw rchart("Diff Recent", [['git', 0.248], ['svn', 3.99]], "Diff contra 4 commits anteriores (269 changed/3609+,6898-)")
      =raw rchart("Diff Tags", [['git', 1.17], ['svn', 83.57]], "Diff duas tags uma contra a outra (v1.9.1.0/v1.9.3.0 )")
      =raw rchart("Log (50)", [['git', 0.012], ['svn', 0.381]], "Log dos 50 últimos commits (19k of output)")
      =raw rchart("Log (All)", [['git', 0.52], ['svn', 169.20]], "Log de todos os commits (26,056 commits - 9.4M of output)")
      =raw rchart("Log (File)", [['git', 0.60], ['svn', 82.84]], "Log do histórico de um único arquivo (array.c - 483 revs)")
      =raw rchart("Update", [['git', 0.90], ['svn', 2.82]], "Pull of Commit A scenario (113 files changed, 2164+, 2259-)")
      =raw rchart("Blame", [['git', 1.91], ['svn', 3.04]], "Anotação de cada linha de um arquivo (array.c)")

    %p
      Note que este é o melhor caso para SVN - um servidor sem carga e com uma banda de 80MB/s com a máquina cliente. Quase todos esses tempos teriam sido piores para o SVN se a conexão fosse mais lenta, enquanto muitos dos tempos do Git não seriam afetados.
    %p
      Fica claro que em muitas dessas operações comuns de controle de versão o <strong>Git é uma ou duas ordens de magnitude mais rápido que o SVN</strong>, mesmo sob condições ideais para o SVN.
    %p
      Um lugar onde o Git é mais lento é a operação de clonagem inicial. Aqui o Git está fazendo o download de todo o histórico, ao invés de apenas as operações mais recentes. Como visto nos gráficos acima, ele não é consideravelmente lento para uma operação que é executada somente uma vez.

    %table.benchmarks
      %tr
        %th Operação
        %th
        %th.right Git*
        %th.right Git
        %th.right SVN
      =raw trchart("Clone", [['git*', 21.0], ['git', 107.50], ['svn', 14.00]], "Clone e clone raso(*) em Git vs checkout no SVN")
      =raw trchart("Size (M)", [[nil, nil], ['git', 181], ['svn', 132]], "Tamanho total dos dados no cliente e arquivos depois do clone/checkout (em M)")

    %p
      Também é interessante notar que o tamanho dos dados no cliente é muito similar, apesar do Git ter todas as versões de todos todos os arquivos para o histórico completo do projeto. Isso ilustra o quão eficiente ele é em comprimir e armazenar dados no cliente.

    %div.bottom-nav
      =link_to "← Ramificando e Fundindo", "#branching-and-merging", {:class => 'previous', 'data-section-id' => 'branching-and-merging'}
      =link_to "Distribuído →", "#distributed", {:class => 'next', 'data-section-id' => 'distributed'}

  %section.about#distributed
    %h2 Distribuído

    %p
      Uma das coisas mais legais sobre SCM distribuídos, incluindo o Git, é que eles são distribuídos. Isso quer dizer que ao invés de fazer um checkout da atual ponta do código fonte, você faz um clone do repositório inteiro.

    %h3 Múltiplos Backups

    %p
      Mesmo que esteja utilizando um fluxo de trabalho centralizado, cada usuário tem em essência um backup completo do servidor principal. Cada uma dessas cópias poderia ser enviada para repor o servidor principal em caso de falha ou corrupção. De fato, não existe um ponto único de falha com Git, ao não ser que exista apenas uma copia do repositório.

    %h3 Qualquer Fluxo de Trabalho

    %p
      Por causa da natureza distribuída do Git e do ótimo sistema de ramificações, um quase sem fim número de fluxos de trabalho pode ser implementado com relativa facilidade.

    %h4 Fluxo estilo Subversion

    %p
      Um fluxo de trabalho centralizado é muito comum, especialmente a partir de pessoas fazendo a transição de sistemas centralizados. Git não vai permitir que envie se alguém envio desde a última vez que buscou atualizações, então um modelo centralizado onde todos os desenvolvedores enviam para o mesmo servidor funciona bem.

    %p.center
      <img src="/images/about/workflow-a@2x.png" width="415" height="209" alt="Workflow A" />

    %h4 Fluxo do Gerente de Integração

    %p
      Outro fluxo comum involve um gerente de integração - uma única pessoa que faz commits para o repositório 'abençoado'. Os desenvolvedores clonam esse repositório, enviam suas mudanças para suas ramificações independentes e pedem ao integrador para puxar suas mudanças para o repositório abençoado. Este é tipo de modelo de desenvolvimento normalmente visto em repositórios de código aberto ou no GitHub.

    %p.center
      <img src="/images/about/workflow-b@2x.png" width="407" height="164" alt="Workflow B" />

    %h4 Fluxo com Ditador e Tenentes

    %p
      Para projetos mais pesados, um fluxo de desenvolvimento como do do Kernel do Linux é frequentemente efetivo.
      Neste modelo, algumas pessoas ('tententes') são responsáveis por subsistemas específicos do projeto e eles fazem a fusão de todas as mudanças relacionadas aquele subsistema. Outro integrador (o 'ditador') pode buscar as mudanças de seus tenentes e então enviar para um repositório 'abençoado', que todos vão clonar novamente.

    %p.center
      <img src="/images/about/workflow-c@2x.png" width="562" height="303" alt="Workflow C" />

    %div.bottom-nav
      =link_to "← Pequeno e Rápido", "#small-and-fast", {:class => 'previous', 'data-section-id' => 'small-and-fast'}
      =link_to "Garantia de Dados →", "#info-assurance", {:class => 'next', 'data-section-id' => 'info-assurance'}

  %section.about#info-assurance
    %h2 Garantia de Dados

    %p
      O modelo de dados que o Git usa garante a integridade criptográfica de cada bit de seu projeto. Cada arquivo e commit gera um checksum, e é buscado por seu checksum quando requisitado novamente. É impossível retirar alguma coisa do Git além dos <strong>exatos bits que colocou lá</strong>.

    %img{:src => "/images/assurance@2x.png", :width => "628", :height => "522"}

    %p
      Também é impossível aterar qualquer arquivo, data, mensagem de commit ou qualquer outro dado em um repositório Git sem mudar os IDs de tudo depois.
      Isso quer dizer que se você tem um ID de commit pode ter certeza de que não somente o seu projeto é exatamente o mesmo de quando fez o commit, mas também que nada no histórico foi alterado.

    %p
      A maioria dos sistemas de controle de versão centralizados não fornece essa integridade por padrão. 

    %div.bottom-nav
      =link_to "← Distribuído", "#distributed", {:class => 'previous', 'data-section-id' => 'distributed'}
      =link_to "Área de Staging →", "#staging-area", {:class => 'next', 'data-section-id' => 'staging-area'}

  %section.about#staging-area
    %h2 Área de Staging

    %p
      Diferente de outros sitemas, Git tem uma coisa chamada de 'Área de Staging' ou 'índice'. Está é uma área intermediária onde os commits podem ser formatados e revisados antes de estarem completos.

    %p
      Uma coisa que diferencia o Git de outras ferramentas é que é possível rapidamente selecionar alguns arquivos e fazer o commit deles sem ter que enviar todos os outros arquivos modificados, e nem ter que listá-los na linha de comando durante o commit.

    %p.center
      <img src="/images/about/index1@2x.png" width="336" height="194" alt="Index 1" />

    %p
      Isso permite selecionar apenas partes de um arquivo modificado. Já foi o tempo em que fazer duas mudanças logicamente não relacionadas a um arquivo para só depois lembrar que esqueceu de fazer commit de uma das mudanças. Agora você pode simplesmente selectionar a mudança que precisa para o commit atual, e deixar as outras mudanças para o próximo commit. Esta funcionalidade se escala para quantas mudanças diferentes para o mesmo arquivo quanto necessárias.

    %p
      E claro, Git também permite que facilmente se ignore essa funcionalidade se você não precisa deste tipo de controle: apenas adicione '-a' para o seu comando de commit para que todas as mudanças em todos os arquivos sejam incluídas.

    %p.center
      <img src="/images/about/index2@2x.png" width="338" height="185" alt="Index 2" />

    %div.bottom-nav
      =link_to "← Garantia de Dados", "#info-assurance", {:class => 'previous', 'data-section-id' => 'info-assurance'}
      =link_to "Livre e de Código Aberto →", "#free-and-open-source", {:class => 'next', 'data-section-id' => 'free-and-open-source'}


  %section.about#free-and-open-source
    %h2 Livre e de Código Aberto

    %p
      Git é publicado sob a licença
      Git is released under the <a href="https://github.com/git/git/blob/master/COPYING">GPLv2</a> <a href="http://www.opensource.org/docs/osd">licença de código aberto</a>. Isso significa que você está livre para <a href="https://github.com/git/git">inspecionar o código fonte</a> a qualquer momeento ou <a href="https://github.com/git/git/blob/master/Documentation/SubmittingPatches">contribuir</a> você mesmo para o projeto.

    %p
      Sob a licença de software GPLv2 do Git, you <strong>pode</strong>:

      %ul.bullets
        %li Usar o Git em projetos abertos ou proprietários de graça, para sempre
        %li Baixar, inspecionar e modificar o código fonte do Git
        %li Fazer mudanças proprietárias para o Git que não sejam distribuídas publicamente
        %li Chamar binários do Git a partir de seu programa aberto ou proprietário
        %li Redistribuir publicamento os binários do Git com programas abertos ou proprietários, desde que eles não sejam modificados ou que as modificações sejam públicas

    %p
      Sob esta licença você <strong>não pode</strong>:

      %ul.bullets
        %li Fazer mudanças proprietárias no Git e distribuir pubicamente sem compartilhar essas mudanças
        %li Fazer mudanças e distribuir publicamente sob uma licença diferente
        %li Usar código fonte do repositório Git em um projeto sob uma licença diferente sem prévia autorização

    %div.bottom-nav
      =link_to "← Área de Staging", "#staging-area", {:class => 'previous', 'data-section-id' => 'staging-area'}
